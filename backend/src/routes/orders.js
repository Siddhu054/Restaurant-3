const express = require("express");
const router = express.Router();
const Order = require("../models/Order");
const Table = require("../models/Table");
const MenuItem = require("../models/MenuItem");

// Create a new order
router.post("/", async (req, res) => {
  console.log("DEBUG: Request body:", req.body); // Log entire request body
  try {
    const { table, items, orderType, status, customerDetails, deliveryInfo } =
      req.body; // Destructure customerDetails and deliveryInfo

    console.log("DEBUG: Delivery Info received:", deliveryInfo); // Log deliveryInfo

    console.log("DEBUG: orderType from request body:", orderType); // Log orderType
    const orderTypeMapped = (orderType || "dine-in").replace("-", "_");
    console.log("DEBUG: Mapped order type:", orderTypeMapped); // Log mapped type

    // Manual validation: table is required for dine-in orders
    if (orderTypeMapped === "dine_in" && !table) {
      return res
        .status(400)
        .json({ message: "Table is required for dine-in orders." });
    }

    // Fetch menu item details to calculate item totals and build order items
    let itemTotal = 0;
    const orderItems = [];
    for (const item of items) {
      // Note: items from frontend now might have _id, name, price, quantity
      // We should use the backend to get the official price by item ID
      const menuItem = await MenuItem.findById(item.menuItem); // <-- Corrected to use item.menuItem
      if (!menuItem) {
        return res
          .status(404)
          .json({ message: `Menu item not found for ID: ${item.menuItem}` }); // <-- Corrected error message
      }
      const itemCalculatedTotal = menuItem.price * item.quantity;
      itemTotal += itemCalculatedTotal;
      orderItems.push({
        menuItem: item.menuItem, // Store item ID
        quantity: item.quantity,
        // cookingInstructions: item.cookingInstructions, // If cooking instructions per item
        price: menuItem.price, // Store item price at the time of order
      });
    }

    // Use deliveryCharge and tax from frontend for now, or implement backend calculation
    const deliveryCharge = deliveryInfo?.deliveryCharge || 0; // Assuming deliveryInfo has deliveryCharge
    const tax = deliveryInfo?.taxes || 0; // Assuming deliveryInfo has taxes
    const grandTotal = itemTotal + deliveryCharge + tax;

    const order = new Order({
      table: orderTypeMapped === "dine_in" ? table : null, // Only assign table for dine-in
      items: orderItems,
      type: orderTypeMapped, // Use the mapped type
      status: status || "processing", // Default to processing
      totalAmount: itemTotal, // Store total before tax/delivery
      deliveryCharge: deliveryCharge,
      tax: tax,
      grandTotal: grandTotal, // Use calculated grand total
      customer: customerDetails, // Save customer details
      cookingInstructions: deliveryInfo?.cookingInstructions, // Save cooking instructions
      estimatedTime: deliveryInfo?.estimatedTime, // <-- Save estimated time
      // orderNumber is generated by a pre-save hook
      // assignedChef can be added later
    });

    const newOrder = await order.save();
    // Populate table and menu items for the response
    // await newOrder.populate("table", "tableNumber");
    // await newOrder.populate("items.menuItem", "name price");
    // Instead, fetch the order again with populate
    const populatedOrder = await Order.findById(newOrder._id)
      .populate("table", "tableNumber")
      .populate("items.menuItem", "name price")
      .populate("customer"); // Populate customer details

    res.status(201).json({
      success: true,
      message: "Order successfully submitted",
      order: populatedOrder,
    });
  } catch (err) {
    console.error("Error creating order:", err);
    // Mongoose validation errors have a specific structure
    if (err.name === "ValidationError") {
      return res.status(400).json({ message: err.message });
    }
    res.status(500).json({ message: "Server Error" });
  }
});

// Get all orders
router.get("/", async (req, res) => {
  try {
    const orders = await Order.find()
      .populate("table", "tableNumber")
      .populate("items.menuItem", "name price");
    res.json(orders);
  } catch (err) {
    console.error("Error fetching orders:", err);
    res.status(500).json({ message: err.message });
  }
});

// Get a single order by ID
router.get("/:id", async (req, res) => {
  try {
    const order = await Order.findById(req.params.id)
      .populate("table", "tableNumber")
      .populate("items.menuItem", "name price");
    if (order == null) {
      return res.status(404).json({ message: "Cannot find order" });
    }
    res.json(order);
  } catch (err) {
    console.error("Error fetching single order:", err);
    res.status(500).json({ message: err.message });
  }
});

// Update an order by ID
router.put("/:id", async (req, res) => {
  try {
    const order = await Order.findById(req.params.id);
    if (order == null) {
      return res.status(404).json({ message: "Cannot find order" });
    }

    // Update fields based on request body
    if (req.body.status != null) {
      order.status = req.body.status;
    }
    // Add other fields to update as needed (e.g., assignedChef, cookingInstructions)

    const updatedOrder = await order.save({ validateBeforeSave: false });
    res.json(updatedOrder);
  } catch (err) {
    console.error("Error updating order:", err);
    res.status(400).json({ message: err.message });
  }
});

// Assign a chef to an order
router.put("/:id/assign-chef", async (req, res) => {
  try {
    const { chefId } = req.body;
    const order = await Order.findById(req.params.id);
    if (!order) return res.status(404).json({ message: "Order not found" });

    order.assignedChef = chefId;
    await order.save();

    res.json({ message: "Chef assigned successfully", order });
  } catch (err) {
    res.status(500).json({ message: "Server error", error: err.message });
  }
});

module.exports = router;
